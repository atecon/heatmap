function strings stock_labels (const matrix X,
                               bool do_cols)
    /* Get stock labels for matrix dimensions */

    strings ret = do_cols ? cnameget(X) : rnameget(X)
    if nelem(ret) == 0
        if do_cols
            scalar dim = cols(X)
            string pref = "col"
        else
            scalar dim = rows(X)
            string pref = "row"
        endif
        ret = array(dim)
        loop i = 1..dim
            ret[i] = sprintf("%s %02d", pref, i)
        endloop
    endif
    return ret
end function

function string tics (scalar x0,
                      scalar x1,
                      scalar n)
    ret = "( "
    pwr = floor(log10((x1-x0)/2))
    scale = 10^pwr
    ini = ceil(x0/scale)
    fin = floor(x1/scale)
    t = seq(ini,fin) * scale
    k = nelem(t)
    dx = (x1 - x0) / (n - 1)
    loop i = 1..k
        pos = (t[i] - x0) / dx
        ret = ret ~ sprintf("\"%.4g\" %g ", t[i], pos)
        if i == k
            ret = ret ~ ")"
        else
            ret = ret ~ ", "
        endif
    endloop
    return ret
end function

function bundle default_opts (void)
    bundle ret

    # general
    ret.dest = "display"
    ret.quiet = 0
    ret.fparam = {}
    ret.max_color_levels = 0
    ret.add_grid = 0

    # colours
    ret.native = 0
    ret.limits = {NA,NA}
    ret.coldest = "blue"
    ret.hottest = "red"
    ret.zerowhite = FALSE

    # labels
    ret.title = ""
    ret.do_labels = FALSE
    string ret.xlabel = ""
    string ret.ylabel = ""
    ret.xtics = ""
    ret.ytics = ""
    ret.printvals = -1

    # font size values
    ret.titlefs = NA
    ret.ticfs = NA
    ret.labelfs = NA
    ret.valfs = NA  # font size for matrix values

    return ret
end function

function void print_palette (const bundle self)
    /* Function to print the color palette settings. */

    printf "set cbrange [%g:%g]\n", self.min_limit, self.max_limit
    if !self.native
        printf "%s\n", makepalette(self.min_limit, self.max_limit, self.zerowhite,
                                   self.coldest, self.hottest)
    endif
end function


function string makepalette (scalar m,
                             scalar M,
                             bool zw,
                             string cold,
                             string hot)
    if zw
        # special cases first
        if m >= 0
            # reds only
            ret = sprintf("set palette defined (0 'white', %g '%s')", M, hot)
        elif M <= 0
            # blues only
            ret = sprintf("set palette defined (%g '%s', 0 'white')", m, cold)
        else
            scale = M - m
            small = 0.05 * scale
            actm = xmin(m, -small)
            actM = xmax(M, small)
            range = actM - actm
            ret = sprintf("set palette defined (0 '%s', %g 'white', %g 'white', %g '%s')", cold, -(small+actm)/range, (small-actm)/range, (actM-actm)/range, hot)
        endif
    else
        # simple
        range = (M - m)
        ret = sprintf("set palette defined (%g '%s', %g '%s')", m/range, cold, M/range, hot)
    endif

    return ret
end function

function scalar is_hex (string c)
    scalar ret = (c[1] == "#") && (strlen(c) == 7)
    if ret
        scalar x = NA
        scalar n = sscanf(c[2:strlen(c)], "%x", x)
        ret = (n == 1)
    endif
    return ret
end function

function scalar colchk (string coldest,
                        string hottest)
    scalar err = !is_hex(coldest)

    if err
        strings colours = strsplit(readfile("@gretldir/data/gnuplot/gpcolors.txt"))
        matrix tmp = instrings(colours, coldest)
        scalar err = nelem(tmp) == 0
    endif

    if !err
        err = !is_hex(hottest)
        if err
            if !exists(colours)
                strings colours = strsplit(readfile("@gretldir/data/gnuplot/gpcolors.txt"))
            endif
            matrix tmp = instrings(colours, hottest)
            scalar err = nelem(tmp) == 0
        endif
        err *= 2
    endif

    return err
end function

function void fix_column_vector_case (matrix *mat)
    # this function "fixes" the column vector case by
    # turning the input matrix in a 3-column matrix with
    # NAs at the sides

    rlab = rnameget(mat)
    clab = cnameget(mat)
    strings newlabs = array(0)
    strings newlabs = nelem(clab) == 1 ? defarray(" ", clab[1], " ") : newlabs

    mat = NA ~ mat ~ NA
    cnameset(mat, newlabs)

    if nelem(rlab)
        rnameset(mat, rlab)
    endif
end function

function scalar get_limit (const scalar val, const scalar fallback)
    # Helper function to get min/max with fallback
    return ok(val) ? val : fallback
end function


function bundle contour_plot (bundle self)
    /* Main function for creating a contour plot */

    scalar self.ncols_mat = cols(self.mat)
    scalar self.nrows_mat = rows(self.mat)
    scalar N = rows(self.mat)  # TODO: get rid of later
    string dest = self.dest

    write_gnuplot_contour(self)
    string buffer = write_gnuplot_heatmap(self)
    gnuplot --input="@buffer" --output="@dest"
    print_creation_message(self)

    return variable
end function


function bundle heatmap_plot (bundle self)
    /* Main function for creating a heatmap plot */

    if self.ncols_mat == 1
        fix_column_vector_case(&self.mat)
        self.ncols_mat = cols(self.mat)
    endif

    if self.do_labels
        strings self.row_names = stock_labels(self.mat, FALSE)
        strings self.column_names = stock_labels(self.mat, 1)
        N = nelem(self.row_names)   # TODO: get rid of later
    else
        scalar N = rows(self.mat)   # TODO: get rid of later
    endif
    string dest = self.dest

    # TODO: improve naming of variables
    scalar self.min_limit = get_limit(self.limits[1], min(self.mat))
    scalar self.max_limit = get_limit(self.limits[2], max(self.mat))

    if self.native
        self.zerowhite = FALSE
    endif

    if self.printvals >= 0
        scalar self.decimale_places = self.printvals
    else
        self.printvals = 0
    endif

    string buffer = write_gnuplot_heatmap(self)
    gnuplot --input="@buffer" --output="@dest"
    print_creation_message(self)

    return variable
end function


function string write_gnuplot_heatmap (const bundle self)
    /* Function writing the actual gnuplot commands for heatmap */

    # Prepare the gnuplot script
    string buffer = ""
    set force_decpoint on

    outfile --tempfile=buffer
        print_enhanced(self.valfs)
        print_title(self.actual_title, self.titlefs)
        printf "unset key\n"
        print_palette(self)
        print_tics_nomirror(self.ticfs)
        print_xrange(self.ncols_mat)

        if self.do_labels
            print_xtics(column_names, self.ncols_mat)
            print_ytics(row_names, self.nrows_mat)
            print_xtics_rotation(N)
        endif

        # The original parameter "xtics" and "ytics" were never documented.
        # I actually think the original code did never work
        #print_custom_xtics_ytics

        print_xlabel(self.xlabel, self.labelfs)
        print_ylabel(self.ylabel, self.labelfs)
        print_autoscale_fix()
        if self.add_grid
            print_add_grid(FALSE)
        endif
        print_matrix_data(self.mat)
        print_plot_matrix_image(self.printvals, self.valfs)

        printf "\n"
    end outfile
    set force_decpoint off

    return buffer
end function


function string write_gnuplot_contour (const bundle self)
    /* Function writing the actual gnuplot commands for contour plot */

    # Prepare the gnuplot script
    string buffer = ""
    set force_decpoint on

    outfile --tempfile=buffer
        print_enhanced(self.valfs)
        print_title(self.actual_title, self.titlefs)
        printf "unset key\n"
        printf "set contour base\n"
        printf "unset surface\n"
        printf "set view map\n"
        print_tics_nomirror(self.ticfs)
        print_xrange(self.ncols_mat)

        if self.do_labels
            print_xtics(column_names, self.ncols_mat)
            print_ytics(row_names, self.nrows_mat)
            print_xtics_rotation(N)
        endif
        #print_custom_xtics_ytics

        print_xlabel(self.xlabel, self.labelfs)
        print_ylabel(self.ylabel, self.labelfs)
        print_autoscale_fix()
        if self.add_grid
            print_add_grid(TRUE)
        endif
        print_contour_linetypes(self.max_color_levels)
        print_matrix_data(self.mat)
        print_splot_matrix_lines()

        printf "\n"
    end outfile
    set force_decpoint off

    return buffer
end function


function void print_creation_message (const bundle self)
    /* Prints a message indicating the plot was created. */
    if !self.quiet
        string ptype = self.do_contour ? "contour plot" : "heatmap"
        if strlen(self.name_mat) == 0
            printf "%s created\n", ptype
        else
            printf "%s for %s created\n", ptype, self.name_mat
        endif
    endif
end function


function void print_splot_matrix_lines(void)
    /* Print the gnuplot command for splotting the matrix with lines */
    printf "splot $data matrix with lines\n"
end function


function void print_plot_matrix_image(scalar printvals, scalar valfs)
    /* Print the gnuplot command for plotting the matrix as an image */

    printf "plot $data matrix with image"
    if printvals
        printf ", $data matrix using 1:2:"
        if ok(valfs)
            printf "(sprintf(\"{/=%d \%.%df}\",$3)) with labels\n", valfs, printvals
        else
            printf "(sprintf(\"\%.%df\",$3)) with labels\n", printvals
        endif
    endif
    printf "\n"
end function

function void print_matrix_data(const matrix mat)
    # Print matrix data for gnuplot in the required format

    matrix m = mreverse(mat)
    cnameset(m, "")
    rnameset(m, "")

    printf "$data << EOD\n"
    printf "%12.5g", m
    printf "EOD\n\n"
end function



function void print_contour_linetypes(scalar max_color_levels)
    # Print gnuplot linetype settings for contour plot levels

    max_color_levels = ceil(max_color_levels)
    max_color_levels = xmin(max_color_levels, 64)
    lw = max_color_levels > 12 ? 1 : 2

    if $version < 20232
        strings lcols = strsplit(sprintf("%06d", zeros(max_color_levels,1)))
    else
        strings lcols = rgbmix("red", "blue", seq(0,max_color_levels-1)/(max_color_levels-1))
    endif

    loop i = 1..max_color_levels
        printf "set linetype %d lc \"#%s\" dt solid lw %d\n", 100+i, lcols[i], lw
    endloop

    printf "set cntrparam bspline levels %d firstlinetype 101\n", max_color_levels
end function



function void print_add_grid(bool do_contour)
    /* This function prints the gnuplot commands to add grid lines to the plot. */

    if do_contour
        printf "set add_grid lw 0.5 lt -1 lc \"#dddddd\"\n"
    else
        printf "set x2tics 1 format '' scale 0,0.001\n"
        printf "set y2tics 1 format '' scale 0,0.001\n"
        printf "set mx2tics 2\nset my2tics 2\n"
        printf "set link x2\nset link y2\n"
        printf "set add_grid front mx2tics my2tics lw 2 lt -1 lc rgb 'white'\n"
    endif
end function


# TODO: not sure whether this actually works
function void print_custom_xtics_ytics (const string xtics, const string ytics)
    /* Print custom x and y tics for gnuplot */

    if strlen(xtics) > 0
        printf "set xtics %s\n", xtics
    endif

    if strlen(ytics) > 0
        printf "set ytics %s\n", ytics
    endif
end function

function void print_autoscale_fix (void)
    /* Print the gnuplot command to set autoscale fix */
    printf "set autoscale fix\n"
end function

function void print_xtics_rotation (scalar N)
    # Prints the gnuplot command to rotate x-axis tics based on N
    scalar angle = N > 9 ? (N > 20 ? 90 : 45) : 0
    printf "set xtics rotate by %d right\n", angle
end function

function void print_ytics (strings row_names, scalar nrows_mat)
    # Prints the y-axis tic labels for a plot in gnuplot format.

    printf "set ytics ("
    loop i = 1..nrows_mat
        s = row_names[i]
        printf("'%s' %d", s, nrows_mat - i)
        if i < nrows_mat
            printf ", "
        endif
    endloop
    printf ") out\n"
end function


function void print_xtics (strings column_names, scalar ncols_mat)
#'
#' Prints the x-axis tic labels for a plot in gnuplot format.
#'
#' @param column_names        A string array containing the column names to be used as tic labels.
#' @param ncols_mat A scalar indicating the number of columns (i.e., number of tics).
#'
#' The function generates and prints the gnuplot 'set xtics' command, formatting the tic labels
#' according to the provided column names and their positions. If there is only one column,
#' it prints a single tic; otherwise, it prints all tics separated by commas.

    printf "set xtics ("
    if ncols_mat == 1
        printf("'%s' %d", column_names[1], 1)
    else
        loop i = 1..ncols_mat
            s = column_names[i]
            printf("'%s' %d", s, i-1)
            if i < ncols_mat
                printf ", "
            endif
        endloop
    endif
    printf ") out\n"
end function


function void print_xrange (scalar ncols_mat)
    /* Print gnuplot set xrange command for columns */
    scalar subtract = 0.5
    printf "set xrange [-0.5:%4.1f]\n", ncols_mat-subtract
end function


function void print_tics_nomirror (const scalar ticfs)
    /* Print 'set tics nomirror' with optional font size */

    printf "set tics nomirror "
    if ok(ticfs)
        printf "font \",%d\"\n", ticfs
    else
        printf "\n"
    endif
end function

function void print_ylabel (const string ylabel, const scalar labelfs)
    /* Print the gnuplot set ylabel command with optional font size */

    if strlen(ylabel) > 0
        string axislab = strsub(ylabel, "\"", "'")
        printf "set ylabel \"%s\" ", axislab
        if ok(labelfs)
            printf "font \",%d\"\n", labelfs
        else
            printf "\n"
        endif
    endif
end function



function void print_xlabel (const string xlabel, const scalar labelfs)
    /* Print the gnuplot set xlabel command with optional font size */

    if strlen(xlabel) > 0
        string axislab = strsub(xlabel, "\"", "'")
        printf "set xlabel \"%s\" ", axislab
        if ok(labelfs)
            printf "font \",%d\"\n", labelfs
        else
            printf "\n"
        endif
    endif
end function


function void print_title (const string title,
                           const scalar fontsize)
    /* code description
    return: type, description */

    printf "set title '%s' ", title
    if ok(fontsize)
        printf "font \",%d\"\n", fontsize
    else
        printf "\n"
    endif
end function


function void print_enhanced (const scalar valfs)
    /* Print enhanced terminal option if valfs (valfs) is set  */
    if ok(valfs)
        printf "set termoption enhanced\n"
    endif
end function



function void heatmap (const matrix mat,
                       bundle opts[null])
    /* Main function */

    bundle self = empty
    if exists(opts)
        bundle self.opts = self + default_opts()
    else
        bundle self = default_opts()
    endif

    ### Process options
    string self.name_mat = argname(mat)
    scalar self.do_contour = self.max_color_levels > 0
    ncols_mat = cols(mat)
    nrows_mat = rows(mat)

    errorif(self.do_contour == TRUE && xmin(nrows_mat, ncols_mat) == 1,
            "Cannot do a contour plot of a vector")

    matrix self.mat = mat
    scalar self.ncols_mat = cols(self.mat)
    scalar self.nrows_mat = rows(self.mat)
    string self.actual_title = strlen(self.title) > 0 ? self.title : argname(mat)

    if self.do_contour == TRUE
        bundle self = contour_plot(self)
    else
        bundle self = heatmap_plot(self)
    endif
end function


function void heatmap_func (string func,
                            scalar res[8::],
                            scalar x0,
                            scalar x1,
                            scalar y0,
                            scalar y1,
                            bundle xopts[null])
    matrix M = mshape(NA, res, res)
    dx = (x1 - x0)/(res-1)
    dy = (y1 - y0)/(res-1)

    opts = defbundle("do_labels", FALSE, "quiet", TRUE)
    self.native = 1
    if exists(xopts)
        opts = opts + xopts
        if inbundle (xopts, "native")
            # explicit takes precedence
            self.native = xopts.native
        endif
    endif

    has_param = inbundle(opts, "fparam")

    scalar x = x0
    loop j = 1..res
        scalar y = y1
        loop i = 1..res
            if has_param
                M[i,j] = feval(func, x, y, self.fparam)
            else
                M[i,j] = feval(func, x, y)
            endif
            y -= dy
        endloop
        x += dx
    endloop

    self.xtics = tics(x0, x1, res)
    self.ytics = tics(y0, y1, res)
    if !inbundle(opts, "title")
        self.title = func ~ "(x,y)"
    endif

    heatmap(M, opts)
end function

function void heatmap_GUI (matrix mat "Matrix to plot",
                           string title[null] "Title",
                           bool do_labels[0] "Add side labels",
                           bool contour[0] "Contour plot",
                           int palette[1:4:1] "Palette" {"native", "zerowhite", "BW", "custom"},
                           string coldest[null] "Coldest color (for use with custom palette)",
      string hottest[null] "Hottest color (for use with custom palette)",
      scalar minimum[NA] "Lower limit for palette",
      scalar maximum[NA] "Upper limit for palette",
      bool pv[0] "Print values",
      int decimal_places[0:6:0] "Decimals")
    bundle opts = defbundle("do_labels", do_labels)
    if contour
        self.max_color_levels = 8
    endif

    self.title = exists(title) ? title : "  "
    self.quiet = TRUE
    self.dest = "display"

    if ok(minimum) || ok(maximum)
        self.limits = {minimum, maximum}
    endif

    # set up some sensible colour schemes

    self.native = FALSE
    if palette == 1
        self.native = TRUE
    elif palette == 2
        self.zerowhite = TRUE
    elif palette == 3
        self.coldest="black"
        self.hottest="white"
    elif palette == 4
        if !(exists(coldest) && exists(hottest))
            print "With a custom color scheme you must specify the 'hot' and 'cold' colors\n"
            print "Reverting to the builtin palette\n"
            self.native = TRUE
        else
            err = colchk(coldest, hottest)
            errorif(err == 1, "Color " ~ coldest ~ " is invalid")
            errorif(err == 2, "Color " ~ hottest ~ " is invalid")
            opts = defbundle("coldest", coldest, "hottest", hottest) + opts
        endif
    endif

    if pv
        self.printvals = decimal_places
    endif

    heatmap(mat, opts)
end function
