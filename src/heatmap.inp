function strings stock_labels (const matrix X,
                               bool do_cols)
    /* Get stock labels for matrix dimensions */

    strings ret = do_cols ? cnameget(X) : rnameget(X)
    if nelem(ret) == 0
        if do_cols
            scalar dim = cols(X)
            string pref = "col"
        else
            scalar dim = rows(X)
            string pref = "row"
        endif
        ret = array(dim)
        loop i = 1..dim
            ret[i] = sprintf("%s %02d", pref, i)
        endloop
    endif
    return ret
end function

function string tics (const scalar x0,
                      const scalar x1,
                      const scalar n)
    /* Generate tic marks for a given range and number of ticks. */

    ret = "( "
    # Guard against degenerate interval
    if x1 == x0
        return ""
    endif

    pwr = floor(log10((x1-x0)/2))
    scale = 10^pwr
    ini = ceil(x0/scale)
    fin = floor(x1/scale)
    t = seq(ini,fin) * scale
    k = nelem(t)
    dx = (x1 - x0) / (n - 1)

    loop i = 1..k
        pos = (t[i] - x0) / dx
        ret = ret ~ sprintf("\"%.4g\" %g ", t[i], pos)
        if i == k
            ret = ret ~ ")"
        else
            ret = ret ~ ", "
        endif
    endloop

    return ret
end function

function bundle default_opts (void)
    /* Function to create a bundle of default options for heatmap plotting. */

    bundle ret

    # general
    ret.dest = "display"
    ret.quiet = 0
    ret.fparam = {}
    ret.clevels = 0
    ret.grid = 0
    ret.input_type = "matrix"

    # colours
    ret.native = 0
    ret.limits = {NA,NA}
    ret.coldest = "blue"
    ret.hottest = "red"
    ret.zerowhite = FALSE

    # labels
    ret.title = ""
    strings ret.varnames = array(0)
    ret.do_labels = FALSE
    string ret.xlabel = ""
    string ret.ylabel = ""
    ret.xtics = ""
    ret.ytics = ""
    ret.printvals = -1

    # Date tics
    string ret.date_format = "%Y-%m"
    scalar ret.date_rotate = 45
    scalar ret.date_offset_x = -3.5
    scalar ret.date_offset_y = -1.4

    # font size values
    ret.titlefs = NA
    ret.ticfs = NA
    ret.labelfs = NA
    ret.valfs = NA  # font size for matrix values

    return ret
end function

function void print_palette (const bundle self)
    /* Function to print the color palette settings. */

    printf "set cbrange [%g:%g]\n", self.min_limit, self.max_limit
    if !self.native
        printf "%s\n", makepalette(self.min_limit, self.max_limit, self.zerowhite,
                                   self.coldest, self.hottest)
    endif
end function


function string makepalette (scalar m,
                             scalar M,
                             bool zw,
                             string cold,
                             string hot)
    /* Create a color palette definition for gnuplot. */

    if zw
        # special cases first
        if m >= 0
            # reds only
            ret = sprintf("set palette defined (0 'white', %g '%s')", M, hot)
        elif M <= 0
            # blues only
            ret = sprintf("set palette defined (%g '%s', 0 'white')", m, cold)
        else
            scale = M - m
            small = 0.05 * scale
            actm = xmin(m, -small)
            actM = xmax(M, small)
            range = actM - actm
            ret = sprintf("set palette defined (0 '%s', %g 'white', %g 'white', %g '%s')", cold, -(small+actm)/range, (small-actm)/range, (actM-actm)/range, hot)
        endif
    else
        # simple
        range = (M - m)
        # avoid division by zero when limits are equal
        if range == 0
            ret = sprintf("set palette defined (0 '%s', 1 '%s')", cold, hot)
        else
            ret = sprintf("set palette defined (%g '%s', %g '%s')", m/range, cold, M/range, hot)
        endif
    endif

    return ret
end function

function scalar is_hex (string c)
    /* Check if a string is a valid hex color code. */

    scalar ret = (c[1] == "#") && (strlen(c) == 7)
    if ret
        scalar x = NA
        scalar n = sscanf(c[2:strlen(c)], "%x", x)
        ret = (n == 1)
    endif

    return ret
end function

function scalar colchk (string coldest,
                        string hottest)
    /* Check if the specified color names are valid. */

    scalar err = !is_hex(coldest)

    if err
        strings colours = strsplit(readfile("@gretldir/data/gnuplot/gpcolors.txt"))
        matrix tmp = instrings(colours, coldest)
        scalar err = nelem(tmp) == 0
    endif

    if !err
        err = !is_hex(hottest)
        if err
            if !exists(colours)
                strings colours = strsplit(readfile("@gretldir/data/gnuplot/gpcolors.txt"))
            endif
            matrix tmp = instrings(colours, hottest)
            scalar err = nelem(tmp) == 0
        endif
        err *= 2
    endif

    return err
end function

/* CURRENTLY FAILS WITH:
The symbol 'BMEMB' is not valid in this context
Syntax error
*** error in function create_heatmap_plot, line 4
*/
/*
function void fix_column_vector_case (matrix *mat)
    # this function "fixes" the column vector case by
    # turning the input matrix in a 3-column matrix with
    # NAs at the sides
    strings rlab = rnameget(mat)
    strings clab = cnameget(mat)
    strings newlabs = array(0)
    strings newlabs = nelem(clab) == 1 ? defarray(" ", clab[1], " ") : newlabs

    mat = NA ~ mat ~ NA
    cnameset(mat, newlabs)

    if nelem(rlab)
        rnameset(mat, rlab)
    endif
end function
*/

function matrix fix_column_vector_case (const matrix mat)
    # this function "fixes" the column vector case by
    # turning the input matrix in a 3-column matrix with
    # NAs at the sides
    strings rlab = rnameget(mat)
    strings clab = cnameget(mat)
    strings newlabs = array(0)
    strings newlabs = nelem(clab) == 1 ? defarray(" ", clab[1], " ") : newlabs

    matrix newmat = NA ~ mat ~ NA
    cnameset(newmat, newlabs)

    if nelem(rlab)
        rnameset(newmat, rlab)
    endif

    return newmat
end function

function scalar get_limit (const scalar val, const scalar fallback)
    # Helper function to get min/max with fallback
    return ok(val) ? val : fallback
end function


function void create_contour_plot (bundle self)
    /* Main function for creating a contour plot */

    scalar self.ncols_mat = cols(self.mat)
    scalar self.nrows_mat = rows(self.mat)
    string dest = self.dest

    string buffer = write_gnuplot_contour(self)
    gnuplot --input="@buffer" --output="@dest"
    print_creation_message(self)
end function


function void create_heatmap_plot (bundle self)
    /* Main function for creating a heatmap plot */

    if self.ncols_mat == 1
        #fix_column_vector_case(&self.mat)
        matrix self.mat = fix_column_vector_case(self.mat)
        scalar self.ncols_mat = cols(self.mat)
    endif
    if self.nrows_mat == 1 && self.input_type != "matrix"
        # add an NA row above and below so the image has visible height
        matrix self.mat = NA ~ self.mat ~ NA
        self.nrows_mat = rows(self.mat)
    endif

    if self.do_labels
        strings self.row_names = stock_labels(self.mat, FALSE)
        strings self.column_names = stock_labels(self.mat, 1)
    endif
    string dest = self.dest

    scalar self.min_limit = get_limit(self.limits[1], min(self.mat))
    scalar self.max_limit = get_limit(self.limits[2], max(self.mat))

    if self.native
        self.zerowhite = FALSE
    endif

    if self.printvals >= 0
        scalar self.decimale_places = self.printvals
    else
        self.printvals = 0
    endif

    string buffer_file = write_gnuplot_heatmap(self)
    #print readfile("@buffer_file") # for debugging only

    gnuplot --input="@buffer_file" --output="@dest"
    print_creation_message(self)
end function


function string write_gnuplot_heatmap (const bundle self)
    /* Function writing the actual gnuplot commands for heatmap */

    # Prepare the gnuplot script
    string buffer_file = ""
    set force_decpoint on

    outfile --tempfile=buffer_file
        print_enhanced(self.valfs)
        print_title(self.actual_title, self.titlefs)
        printf "unset key\n"
        print_palette(self)
        print_tics_nomirror(self.ticfs)
        print_xrange(self.ncols_mat)

        # Currently not needed
        #if self.nrows_mat == 1 && self.input_type != "matrix"
        #    #print_yrange(self.nrows_mat)
        #endif

        if self.do_labels && self.input_type == "matrix"
            print_xtics(column_names, self.ncols_mat, self.ticfs)
            print_ytics(row_names, self.nrows_mat, self.ticfs)
            print_xtics_rotation(N)
        elif self.input_type != "matrix" # either series or list
            print_datetics(self.obsdate, self)
            if $datatype == 2 # time-series
                print_ytics(self.varnames, nelem(self.varnames), self.ticfs)
            elif $datatype == 3 # panel
                catch markers --to-array=Markers
                if !$error
                    strings Markers = struniq(Markers)
                    print_ytics(Markers, nelem(Markers), self.ticfs)
                endif
            endif
        endif
        # The original parameter "xtics" and "ytics" were never documented.
        # I actually think the original code did never work
        #print_custom_xtics_ytics

        print_xlabel(self.xlabel, self.labelfs)
        print_ylabel(self.ylabel, self.labelfs)
        print_autoscale_fix()
        if self.grid
            print_add_grid(FALSE)
        endif
        print_data_block(self.mat)
        print_plot_matrix_image(self.printvals, self.valfs)
        printf "\n"
    end outfile

    set force_decpoint off

    return buffer_file
end function


function void create_contour_plot (bundle self)
    /* Main function for creating a contour plot */

    scalar self.ncols_mat = cols(self.mat)
    scalar self.nrows_mat = rows(self.mat)
    string dest = self.dest

    string buffer = write_gnuplot_contour(self)
    gnuplot --input="@buffer" --output="@dest"
    print_creation_message(self)
end function

function string write_gnuplot_contour (const bundle self)
    /* Function writing the actual gnuplot commands for contour plot */

    # Prepare the gnuplot script
    string buffer_file = ""
    set force_decpoint on

    outfile --tempfile=buffer_file
        print_enhanced(self.valfs)
        print_title(self.actual_title, self.titlefs)
        printf "unset key\n"
        printf "set contour base\n"
        printf "unset surface\n"
        printf "set view map\n"
        print_tics_nomirror(self.ticfs)
        print_xrange(self.ncols_mat)

        if self.do_labels
            print_xtics(column_names, self.ncols_mat, self.ticfs)
            print_ytics(row_names, self.nrows_mat, self.ticfs)
            print_xtics_rotation(N)
        endif
        #print_custom_xtics_ytics

        print_xlabel(self.xlabel, self.labelfs)
        print_ylabel(self.ylabel, self.labelfs)
        print_autoscale_fix()
        if self.grid
            print_add_grid(TRUE)
        endif
        print_contour_linetypes(self.clevels)
        print_data_block(self.mat)
        print_splot_matrix_lines()

        printf "\n"
    end outfile
    set force_decpoint off

    return buffer_file
end function


function void print_creation_message (const bundle self)
    /* Prints a message indicating the plot was created. */
    if !self.quiet
        string ptype = self.do_contour ? "contour plot" : "heatmap"
        if strlen(self.name_mat) == 0
            printf "%s created\n", ptype
        else
            printf "%s for %s created\n", ptype, self.name_mat
        endif
    endif
end function


function void print_splot_matrix_lines(void)
    /* Print the gnuplot command for splotting the matrix with lines */
    printf "splot $data matrix with lines\n"
end function


function void print_plot_matrix_image(scalar printvals, scalar valfs)
    /* Print the gnuplot command for plotting the matrix as an image */

    printf "plot $data matrix with image"
    if printvals
        printf ", $data matrix using 1:2:"
        if ok(valfs)
            printf "(sprintf(\"{/=%d \%.%df}\",$3)) with labels\n", valfs, printvals
        else
            printf "(sprintf(\"\%.%df\",$3)) with labels\n", printvals
        endif
    endif
    printf "\n"
end function

function void print_data_block(const matrix mat)
    # Print matrix data for gnuplot in the required format

    matrix m = mreverse(mat)
    cnameset(m, "")
    rnameset(m, "")

    printf "$data << EOD\n"
    printf "%12.5g", m
    printf "EOD\n\n"
end function



function void print_contour_linetypes(scalar clevels)
    # Print gnuplot linetype settings for contour plot levels

    clevels = ceil(clevels)
    clevels = xmin(clevels, 64)
    lw = clevels > 12 ? 1 : 2

    if $version < 20232
        strings lcols = strsplit(sprintf("%06d", zeros(clevels,1)))
    else
        strings lcols = rgbmix("red", "blue", seq(0,clevels-1)/(clevels-1))
    endif

    loop i = 1..clevels
        printf "set linetype %d lc \"#%s\" dt solid lw %d\n", 100+i, lcols[i], lw
    endloop

    printf "set cntrparam bspline levels %d firstlinetype 101\n", clevels
end function



function void print_add_grid (bool do_contour)
    /* This function prints the gnuplot commands to add grid lines to the plot. */

    if do_contour
        printf "set grid lw 0.5 lt -1 lc \"#dddddd\"\n"
    else
        printf "set x2tics 1 format '' scale 0,0.001\n"
        printf "set y2tics 1 format '' scale 0,0.001\n"
        printf "set mx2tics 2\nset my2tics 2\n"
        printf "set link x2\nset link y2\n"
        printf "set grid front mx2tics my2tics lw 2 lt -1 lc rgb 'white'\n"
    endif
end function


# Currently not needed
/*
function void print_custom_xtics_ytics (const string xtics, const string ytics)
    # Print custom x and y tics for gnuplot

    if strlen(xtics) > 0
        printf "set xtics %s\n", xtics
    endif

    if strlen(ytics) > 0
        printf "set ytics %s\n", ytics
    endif
end function
*/

function void print_autoscale_fix (void)
    /* Print the gnuplot command to set autoscale fix */
    printf "set autoscale fix\n"
end function

function void print_xtics_rotation (scalar N)
    # Prints the gnuplot command to rotate x-axis tics based on N
    scalar angle = N > 9 ? (N > 20 ? 90 : 45) : 0
    printf "set xtics rotate by %d right\n", angle
end function

function void print_ytics (strings row_names, scalar nrows_mat, const scalar fontsize)
    # Prints the y-axis tic labels for a plot in gnuplot format.

    printf "set ytics ("
    loop i = 1..nrows_mat
        s = row_names[i]
        printf("'%s' %d", s, nrows_mat - i)
        if i < nrows_mat
            printf ", "
        endif
    endloop
    printf ") out font \",%g\"\n", fontsize
end function


function void print_xtics (strings column_names, scalar ncols_mat, const scalar fontsize)
#'
#' Prints the x-axis tic labels for a plot in gnuplot format.
#'
#' @param column_names        A string array containing the column names to be used as tic labels.
#' @param ncols_mat A scalar indicating the number of columns (i.e., number of tics).
#'
#' The function generates and prints the gnuplot 'set xtics' command, formatting the tic labels
#' according to the provided column names and their positions. If there is only one column,
#' it prints a single tic; otherwise, it prints all tics separated by commas.

    printf "set xtics ("
    if ncols_mat == 1
        # Gnuplot matrix columns are indexed from 0 to n-1, and the
        # multi-column branch already uses i-1 for positions. The
        # single-column case previously used position 1, which put the tic
        # label one unit to the right (misaligned with the lone column and
        # outside the plotted column center given by set xrange [-0.5:n-0.5]).
        # Changing it to 0 aligns the label with the actual column position and keeps behavior consistent with the multi-column branch.
        printf("'%s' %d", column_names[1], 0) # before: <", 1)">
    else
        loop i = 1..ncols_mat
            s = column_names[i]
            printf("'%s' %d", s, i-1)
            if i < ncols_mat
                printf ", "
            endif
        endloop
    endif
    printf ") out font \",%g\"\n", fontsize
end function


function void print_xrange (scalar ncols_mat)
    /* Print gnuplot set xrange command for columns */
    scalar subtract = 0.5
    printf "set xrange [-0.5:%4.1f]\n", ncols_mat-subtract
end function

function void print_yrange (scalar nrows_mat)
    /* Print gnuplot set yrange command for rows */
    scalar subtract = 0.5
    printf "set yrange [%4.1f:%4.1f]\n", -subtract, nrows_mat-subtract
end function


function void print_tics_nomirror (const scalar ticfs)
    /* Print 'set tics nomirror' with optional font size */

    printf "set tics nomirror "
    if ok(ticfs)
        printf "font \",%d\"\n", ticfs
    else
        printf "\n"
    endif
end function

function void print_ylabel (const string ylabel, const scalar labelfs)
    /* Print the gnuplot set ylabel command with optional font size */

    if strlen(ylabel) > 0
        string axislab = strsub(ylabel, "\"", "'")
        printf "set ylabel \"%s\" ", axislab
        if ok(labelfs)
            printf "font \",%d\"\n", labelfs
        else
            printf "\n"
        endif
    endif
end function



function void print_xlabel (const string xlabel, const scalar labelfs)
    /* Print the gnuplot set xlabel command with optional font size */

    if strlen(xlabel) > 0
        string axislab = strsub(xlabel, "\"", "'")
        printf "set xlabel \"%s\" ", axislab
        if ok(labelfs)
            printf "font \",%d\"\n", labelfs
        else
            printf "\n"
        endif
    endif
end function


function void print_title (const string title,
                           const scalar fontsize)
    /* code description
    return: type, description */

    printf "set title '%s' ", title
    if ok(fontsize)
        printf "font \",%d\"\n", fontsize
    else
        printf "\n"
    endif
end function


function void print_enhanced (const scalar valfs)
    /* Print enhanced terminal option if valfs (valfs) is set  */
    if ok(valfs)
        printf "set termoption enhanced\n"
    endif
end function



function void heatmap (const matrix mat,
                       bundle opts[null])
    /* Main function */

    bundle self = empty
    if exists(opts)
        bundle self = opts + default_opts()
    else
        bundle self = default_opts()
    endif

    ### Process options
    string self.name_mat = argname(mat)
    scalar self.do_contour = self.clevels > 0
    ncols_mat = cols(mat)
    nrows_mat = rows(mat)

    errorif(self.do_contour == TRUE && xmin(nrows_mat, ncols_mat) == 1,
            "Cannot do a contour plot of a vector")

    matrix self.mat = mat
    scalar self.ncols_mat = cols(self.mat)
    scalar self.nrows_mat = rows(self.mat)
    string self.actual_title = set_title(self)

    if self.do_contour == TRUE
        create_contour_plot(self)
    else
        create_heatmap_plot(self)
    endif
end function





function void contour_plot (const matrix mat, bundle opts[null], scalar clevels[::8])
    /* Create a contour plot: ensure clevels is set (default 8) and call heatmap().
       Convenience public wrapper for heatmap(). */

    bundle myopts = exists(opts) ? opts + default_opts() : default_opts()

    if ok(clevels)
        myopts.clevels = clevels
    elif !inbundle(myopts, "clevels") || myopts.clevels == 0
        myopts.clevels = 8
    endif

    heatmap(mat, myopts)
end function


function void heatmap_plot (const numeric Input, bundle opts[null])
    /* Create a standard heatmap: accept matrix, series (time/panel) or a list of time-series;
       force clevels=0 and call heatmap(). */

    bundle self = exists(opts) ? opts + default_opts() : default_opts()
    scalar self.clevels = 0
    string self.input_type = typename(Input)
    scalar data_type = $datatype
    matrix mat = {}

    if self.input_type == "matrix"
        mat = Input
    else  # series or list are passed
        errorif(data_type == 1,
                "Cross-sectional series are not supported for heatmap_plot()")

        # If data_type is time-series (data_type=2): Accept series and list
        if data_type == 2
            # single time series or list accepted
            mat = {Input}
        else
            # If data_type is of type panel (data_type=3): Accept series only
            errorif(data_type == 3 && self.input_type != "series",
                    "Panel data must be a series")
            mat = {Input}

            # panel series:
            # Each column refers to a cross-sectional unit; row refers to time dim.
            scalar num_periods = $pd
            scalar n_units = $nobs / num_periods
            mat = mshape({Input}, num_periods, n_units)
        endif

        mat = transp(mat)
        series self.obsdate = $obsdate
    endif

    # Retrieve variable names
    if self.input_type == "list"
        strings self.varnames = varnames(Input)
    else
        strings self.varnames = defarray(argname(Input))
    endif

    heatmap(mat, self)
end function


function void heatmap_func (string func,
                            scalar res[8::],
                            scalar x0,
                            scalar x1,
                            scalar y0,
                            scalar y1,
                            bundle xopts[null])
    /* This function produces a heatmap plot of a two-variable function,
       with resolution given by the scalar res. */

    matrix mat = mshape(NA, res, res)
    scalar dx = (x1 - x0)/(res-1)
    scalar dy = (y1 - y0)/(res-1)
    bundle self = defbundle("do_labels", FALSE, "quiet", TRUE)
    scalar self.native = 1
    scalar has_param = inbundle(self, "fparam")
    scalar x = x0

    if exists(xopts)
        self = self + xopts
        if inbundle (xopts, "native")
            # explicit takes precedence
            self.native = xopts.native
        endif
    endif

    loop j = 1..res
        scalar y = y1
        loop i = 1..res
            if has_param
                mat[i,j] = feval(func, x, y, self.fparam)
            else
                mat[i,j] = feval(func, x, y)
            endif
            y -= dy
        endloop
        x += dx
    endloop

    self.xtics = tics(x0, x1, res)
    self.ytics = tics(y0, y1, res)
    if !inbundle(self, "title")
        self.title = func ~ "(x,y)"
    endif

    heatmap(mat, self)
end function


function void heatmap_GUI (matrix mat "Matrix to plot",
                           string title[null] "Title",
                           bool do_labels[0] "Add side labels",
                           bool contour[0] "Contour plot",
                           int palette[1:4:1] "Palette" {"native", "zerowhite", "BW", "custom"},
                           string coldest[null] "Coldest color (for use with custom palette)",
                           string hottest[null] "Hottest color (for use with custom palette)",
                           scalar minimum[NA] "Lower limit for palette",
                           scalar maximum[NA] "Upper limit for palette",
                           bool pv[0] "Print values",
                           int decimal_places[0:6:0] "Decimals")
    /* GUI function */

    bundle opts = defbundle("do_labels", do_labels)
    if contour
        scalar self.clevels = 8
    endif

    string self.title = exists(title) ? title : "  "
    scalar self.quiet = TRUE
    string self.dest = "display"

    if ok(minimum) || ok(maximum)
        self.limits = {minimum, maximum}
    endif

    # set up some sensible colour schemes
    self.native = FALSE
    if palette == 1
        self.native = TRUE
    elif palette == 2
        self.zerowhite = TRUE
    elif palette == 3
        self.coldest="black"
        self.hottest="white"
    elif palette == 4
        if !(exists(coldest) && exists(hottest))
            print "With a custom color scheme you must specify the 'hot' and 'cold' colors\n"
            print "Reverting to the builtin palette\n"
            self.native = TRUE
        else
            err = colchk(coldest, hottest)
            errorif(err == 1, "Color " ~ coldest ~ " is invalid")
            errorif(err == 2, "Color " ~ hottest ~ " is invalid")
            opts = defbundle("coldest", coldest, "hottest", hottest) + opts
        endif
    endif

    if pv
        self.printvals = decimal_places
    endif

    heatmap(mat, opts)
end function

function void print_datetics (const series obsdate,
                              const bundle self)
    /* Print gnuplot commands to set x-axis tics from an ISO8601 integer series.
       fmt: optional format string using %Y, %m, %d. */

    matrix dates = values(obsdate)  # values() needed for panel data
    scalar n = nobs(dates)
    # choose at most ~10 labels to avoid clutter
    scalar maxlabels = 10
    scalar step = n > maxlabels ? ceil(n / maxlabels) : 1

    printf "set xtics ("
    scalar first = 1
    loop i = 1..n
        if i == 1 || i == n || ((i-1) % step == 0)
            scalar val = dates[i]
            # assume ISO date as integer YYYYMMDD (or YYYYMM)
            scalar year = floor(val/10000)
            scalar month = floor((val - year*10000) / 100)
            scalar day = val - year*10000 - month*100

            string lab = self.date_format
            lab = strsub(lab, "%Y", sprintf("%04d", year))
            lab = strsub(lab, "%m", sprintf("%02d", month))
            lab = strsub(lab, "%d", sprintf("%02d", day))

            if first
                printf("'%s' %d", lab, i-1)
                first = 0
            else
                printf(", '%s' %d", lab, i-1)
            endif
        endif

    endloop
    printf ") out rotate by %g offset %g,%g font ',%g'\n",
        self.date_rotate, self.date_offset_x, self.date_offset_y, self.labelfs
end function


function string set_title (const bundle self)
    /* Set the title for the heatmap */

    string ret = ""
    if strlen(self.title) > 0
        ret = self.title
    else
        strings vnames = self.varnames
        loop foreach i vnames
            ret += sprintf("%s", vnames[i])
            if i < nelem(vnames)
                ret += ", "
            endif
        endloop
    endif

    return ret
end function